// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Code generated by MockGen. DO NOT EDIT.
// Source: internal/checkout/checkout.go

// Package mock_checkout is a generated GoMock package.
package mock_checkout

import (
	gomock "github.com/golang/mock/gomock"
	git "go.chromium.org/chromiumos/infra/go/internal/git"
	repo "go.chromium.org/chromiumos/infra/go/internal/repo"
	reflect "reflect"
	regexp "regexp"
)

// MockCheckout is a mock of Checkout interface
type MockCheckout struct {
	ctrl     *gomock.Controller
	recorder *MockCheckoutMockRecorder
}

// MockCheckoutMockRecorder is the mock recorder for MockCheckout
type MockCheckoutMockRecorder struct {
	mock *MockCheckout
}

// NewMockCheckout creates a new mock instance
func NewMockCheckout(ctrl *gomock.Controller) *MockCheckout {
	mock := &MockCheckout{ctrl: ctrl}
	mock.recorder = &MockCheckoutMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCheckout) EXPECT() *MockCheckoutMockRecorder {
	return m.recorder
}

// Initialize mocks base method
func (m *MockCheckout) Initialize(root, manifestUrl string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Initialize", root, manifestUrl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Initialize indicates an expected call of Initialize
func (mr *MockCheckoutMockRecorder) Initialize(root, manifestUrl interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockCheckout)(nil).Initialize), root, manifestUrl)
}

// Manifest mocks base method
func (m *MockCheckout) Manifest() repo.Manifest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Manifest")
	ret0, _ := ret[0].(repo.Manifest)
	return ret0
}

// Manifest indicates an expected call of Manifest
func (mr *MockCheckoutMockRecorder) Manifest() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Manifest", reflect.TypeOf((*MockCheckout)(nil).Manifest))
}

// SetRepoToolPath mocks base method
func (m *MockCheckout) SetRepoToolPath(path string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRepoToolPath", path)
}

// SetRepoToolPath indicates an expected call of SetRepoToolPath
func (mr *MockCheckoutMockRecorder) SetRepoToolPath(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRepoToolPath", reflect.TypeOf((*MockCheckout)(nil).SetRepoToolPath), path)
}

// SyncToManifest mocks base method
func (m *MockCheckout) SyncToManifest(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncToManifest", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncToManifest indicates an expected call of SyncToManifest
func (mr *MockCheckoutMockRecorder) SyncToManifest(path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncToManifest", reflect.TypeOf((*MockCheckout)(nil).SyncToManifest), path)
}

// ReadVersion mocks base method
func (m *MockCheckout) ReadVersion() (repo.VersionInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadVersion")
	ret0, _ := ret[0].(repo.VersionInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadVersion indicates an expected call of ReadVersion
func (mr *MockCheckoutMockRecorder) ReadVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadVersion", reflect.TypeOf((*MockCheckout)(nil).ReadVersion))
}

// AbsolutePath mocks base method
func (m *MockCheckout) AbsolutePath(args ...string) string {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AbsolutePath", varargs...)
	ret0, _ := ret[0].(string)
	return ret0
}

// AbsolutePath indicates an expected call of AbsolutePath
func (mr *MockCheckoutMockRecorder) AbsolutePath(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbsolutePath", reflect.TypeOf((*MockCheckout)(nil).AbsolutePath), args...)
}

// AbsoluteProjectPath mocks base method
func (m *MockCheckout) AbsoluteProjectPath(project repo.Project, args ...string) string {
	m.ctrl.T.Helper()
	varargs := []interface{}{project}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AbsoluteProjectPath", varargs...)
	ret0, _ := ret[0].(string)
	return ret0
}

// AbsoluteProjectPath indicates an expected call of AbsoluteProjectPath
func (mr *MockCheckoutMockRecorder) AbsoluteProjectPath(project interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{project}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbsoluteProjectPath", reflect.TypeOf((*MockCheckout)(nil).AbsoluteProjectPath), varargs...)
}

// BranchExists mocks base method
func (m *MockCheckout) BranchExists(project repo.Project, pattern *regexp.Regexp) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BranchExists", project, pattern)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BranchExists indicates an expected call of BranchExists
func (mr *MockCheckoutMockRecorder) BranchExists(project, pattern interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BranchExists", reflect.TypeOf((*MockCheckout)(nil).BranchExists), project, pattern)
}

// EnsureProject mocks base method
func (m *MockCheckout) EnsureProject(project repo.Project) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureProject", project)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureProject indicates an expected call of EnsureProject
func (mr *MockCheckoutMockRecorder) EnsureProject(project interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureProject", reflect.TypeOf((*MockCheckout)(nil).EnsureProject), project)
}

// GitRevision mocks base method
func (m *MockCheckout) GitRevision(project repo.Project) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GitRevision", project)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GitRevision indicates an expected call of GitRevision
func (mr *MockCheckoutMockRecorder) GitRevision(project interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GitRevision", reflect.TypeOf((*MockCheckout)(nil).GitRevision), project)
}

// RunGit mocks base method
func (m *MockCheckout) RunGit(project repo.Project, cmd []string) (git.CommandOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunGit", project, cmd)
	ret0, _ := ret[0].(git.CommandOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunGit indicates an expected call of RunGit
func (mr *MockCheckoutMockRecorder) RunGit(project, cmd interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunGit", reflect.TypeOf((*MockCheckout)(nil).RunGit), project, cmd)
}

// BumpVersion mocks base method
func (m *MockCheckout) BumpVersion(component repo.VersionComponent, branch, commitMsg string, dryRun, fetch bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BumpVersion", component, branch, commitMsg, dryRun, fetch)
	ret0, _ := ret[0].(error)
	return ret0
}

// BumpVersion indicates an expected call of BumpVersion
func (mr *MockCheckoutMockRecorder) BumpVersion(component, branch, commitMsg, dryRun, fetch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BumpVersion", reflect.TypeOf((*MockCheckout)(nil).BumpVersion), component, branch, commitMsg, dryRun, fetch)
}
